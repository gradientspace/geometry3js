{"version":3,"sources":["webpack:///webpack/bootstrap 253c5d7291e8496f35b0","webpack:///./src/util/Constants.js","webpack:///./src/g3.js","webpack:///./src/types/AxisAlignedBox2d.js","webpack:///./src/types/Vector2d.js","webpack:///./src/util/MathUtil.js","webpack:///./src/curve2/GeneralPolygon2d.js","webpack:///./src/curve2/Polygon2d.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;AC1BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;ACzCA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;ACrHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;ACrJA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AC9EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;AC5DA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC","file":"g3.webpack.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 253c5d7291e8496f35b0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"../types/Vector2d\");\nconst AxisAlignedBox2d_1 = require(\"../types/AxisAlignedBox2d\");\nclass Constants {\n    static get AxisAlignedBox2d_Empty() {\n        return new AxisAlignedBox2d_1.g3AxisAlignedBox2d();\n    }\n}\nConstants.MaxDouble = Number.MAX_VALUE;\nConstants.MinDouble = Number.MIN_VALUE;\nConstants.MaxInt = Number.MAX_SAFE_INTEGER;\nConstants.MinInt = Number.MIN_SAFE_INTEGER;\nConstants.Deg2Rad = (Math.PI / 180.0);\nConstants.Rad2Deg = (180.0 / Math.PI);\nConstants.TwoPI = 2.0 * Math.PI;\nConstants.HalfPI = 0.5 * Math.PI;\nConstants.ZeroTolerance = 1e-08;\nConstants.Epsilon = 2.2204460492503131e-016;\nConstants.Vector2d_Zero = new Vector2d_1.Vector2dConstant(0, 0);\nConstants.Vector2d_One = new Vector2d_1.Vector2dConstant(1, 1);\nConstants.Vector2d_AxisX = new Vector2d_1.Vector2dConstant(1, 0);\nConstants.Vector2d_AxisY = new Vector2d_1.Vector2dConstant(0, 1);\nConstants.Vector2d_Max = new Vector2d_1.Vector2dConstant(Constants.MaxDouble, Constants.MaxDouble);\nConstants.Vector2d_Min = new Vector2d_1.Vector2dConstant(Constants.MinDouble, Constants.MinDouble);\nexports.default = Constants;\n//# sourceMappingURL=Constants.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/Constants.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"./types/Vector2d\");\nconst AxisAlignedBox2d_1 = require(\"./types/AxisAlignedBox2d\");\nconst Polygon2d_1 = require(\"./curve2/Polygon2d\");\nconst GeneralPolygon2d_1 = require(\"./curve2/GeneralPolygon2d\");\nconst Constants_1 = require(\"./util/Constants\");\n/*\n * Type factories\n */\nfunction Vector2d(x, y) {\n    return new Vector2d_1.g3Vector2d(x, y);\n}\nexports.Vector2d = Vector2d;\nfunction Vector2dIndexable(x, y) {\n    return new Vector2d_1.IndexedVector2d(x, y);\n}\nexports.Vector2dIndexable = Vector2dIndexable;\nfunction AxisAlignedBox2d(min = Constants_1.default.Vector2d_Max, max = Constants_1.default.Vector2d_Min) {\n    return new AxisAlignedBox2d_1.g3AxisAlignedBox2d(min, max);\n}\nexports.AxisAlignedBox2d = AxisAlignedBox2d;\nfunction Polygon2d(n = 0) {\n    return new Polygon2d_1.g3Polygon2d(n);\n}\nexports.Polygon2d = Polygon2d;\nfunction GeneralPolygon2d() {\n    return new GeneralPolygon2d_1.g3GeneralPolygon2d();\n}\nexports.GeneralPolygon2d = GeneralPolygon2d;\n/*\n * top-level math functions\n */\nfunction addv2(a, b) {\n    return new Vector2d_1.g3Vector2d(a.x + b.x, a.y + b.y);\n}\nexports.addv2 = addv2;\nfunction addv(a, b) {\n    return a.clone().addv(b);\n}\nexports.addv = addv;\n//# sourceMappingURL=g3.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/g3.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Constants_1 = require(\"../util/Constants\");\nconst g3 = require(\"../g3\");\nconst MathUtil_1 = require(\"../util/MathUtil\");\nclass g3AxisAlignedBox2d {\n    constructor(min = Constants_1.default.Vector2d_Max, max = Constants_1.default.Vector2d_Min) {\n        this.Min = min.clone();\n        this.Max = max.clone();\n    }\n    clone() {\n        return g3.AxisAlignedBox2d(this.Min, this.Max);\n    }\n    get Width() {\n        return this.Max.x - this.Min.x;\n    }\n    get Height() {\n        return this.Max.y - this.Min.y;\n    }\n    get Area() {\n        return (this.Max.x - this.Min.x) * (this.Max.y - this.Min.y);\n    }\n    get DiagonalLength() {\n        let dx = this.Max.x - this.Min.x;\n        let dy = this.Max.y - this.Min.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    get MaxDim() {\n        return Math.max(this.Max.x - this.Min.x, this.Max.y - this.Min.y);\n    }\n    get Diagonal() {\n        return g3.Vector2d(this.Max.x - this.Min.x, this.Max.y - this.Min.y);\n    }\n    get Center() {\n        return g3.Vector2d(0.5 * (this.Max.x + this.Min.x), 0.5 * (this.Max.y + this.Min.y));\n    }\n    /** ccw from bottom-left, 0 == bottom-left, 1 = bottom-right, 2 == top-right, 3 == top-left */\n    Corner(i) {\n        return g3.Vector2d((i % 3 == 0) ? this.Min.x : this.Max.x, (i < 2) ? this.Min.y : this.Max.y);\n    }\n    Expand(f) {\n        this.Min.x -= f;\n        this.Min.y -= f;\n        this.Max.x += f;\n        this.Max.y += f;\n    }\n    Contract(f) {\n        f = MathUtil_1.default.SignedClamp(this.MaxDim, f);\n        this.Expand(-f);\n    }\n    /** values are all added. this is a weird function... */\n    Pad(left, right, bottom, top) {\n        this.Min.x += left;\n        this.Min.y += bottom;\n        this.Max.x += right;\n        this.Max.y += top;\n    }\n    Translate(v) {\n        this.Min.addv(v);\n        this.Max.addv(v);\n    }\n    ContainPoint(v) {\n        this.Min.x = Math.min(this.Min.x, v.x);\n        this.Min.y = Math.min(this.Min.y, v.y);\n        this.Max.x = Math.max(this.Max.x, v.x);\n        this.Max.y = Math.max(this.Max.y, v.y);\n    }\n    ContainBox(b) {\n        this.ContainPoint(b.Min);\n        this.ContainPoint(b.Max);\n    }\n    Intersect(box) {\n        let minx = Math.max(this.Min.x, box.Min.x);\n        let miny = Math.max(this.Min.y, box.Min.y);\n        let maxx = Math.min(this.Max.x, box.Max.x);\n        let maxy = Math.min(this.Max.y, box.Max.y);\n        let width = maxx - minx;\n        let height = maxy - miny;\n        return (height <= 0 || width <= 0) ? Constants_1.default.AxisAlignedBox2d_Empty :\n            g3.AxisAlignedBox2d(g3.Vector2d(minx, miny), g3.Vector2d(maxx, maxy));\n    }\n    ContainsPoint(v) {\n        return (this.Min.x < v.x) && (this.Min.y < v.y) && (this.Max.x > v.x) && (this.Max.y > v.y);\n    }\n    ContainsBox(box2) {\n        return this.ContainsPoint(box2.Min) && this.ContainsPoint(box2.Max);\n    }\n    Intersects(box) {\n        return !((box.Max.x < this.Min.x) || (box.Min.x > this.Max.x) || (box.Max.y < this.Min.y) || (box.Min.y > this.Max.y));\n    }\n    /** returns 0 if point is inside box */\n    Distance(v) {\n        let cx = 0.5 * (this.Max.x + this.Min.x);\n        let cy = 0.5 * (this.Max.y + this.Min.y);\n        let dx = Math.abs(v.x - cx);\n        let dy = Math.abs(v.y - cy);\n        let fWidth = this.Max.x - this.Min.x;\n        let fHeight = this.Max.y - this.Min.y;\n        if (dx < fWidth && dy < fHeight) {\n            return 0.0;\n        }\n        else if (dx > fWidth && dy > fHeight) {\n            return Math.sqrt((dx - fWidth) * (dx - fWidth) + (dy - fHeight) * (dy - fHeight));\n        }\n        else if (dx > fWidth) {\n            return dx - fWidth;\n        }\n        else if (dy > fHeight) {\n            return dy - fHeight;\n        }\n        return 0.0;\n    }\n    toString() {\n        return \"[\" + this.Min.x + \",\" + this.Max.x + \"][\" + this.Min.y + \",\" + this.Max.y + \"]\";\n    }\n}\nexports.g3AxisAlignedBox2d = g3AxisAlignedBox2d;\n//# sourceMappingURL=AxisAlignedBox2d.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/types/AxisAlignedBox2d.js\n// module id = 2\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * \"Normal\" implementation of Vector2d, has .x and .y properties\n */\nclass g3Vector2d {\n    // implement methods for Array here\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    toString() {\n        return \"[\" + this.x + \",\" + this.y + \"]\";\n    }\n    clone() {\n        return new g3Vector2d(this.x, this.y);\n    }\n    Length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    LengthSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    at(i) {\n        return (i == 0) ? this.x : this.y;\n    }\n    set(b) {\n        this.x = b.x;\n        this.y = b.y;\n        return this;\n    }\n    addv(b) {\n        this.x += b.x;\n        this.y += b.y;\n        return this;\n    }\n    subv(b) {\n        this.x -= b.x;\n        this.y -= b.y;\n        return this;\n    }\n    mulf(f) {\n        this.x *= f;\n        this.y *= f;\n        return this;\n    }\n    divf(f) {\n        this.x /= f;\n        this.y /= f;\n        return this;\n    }\n}\nexports.g3Vector2d = g3Vector2d;\n/**\n * This is a Vector2d that provides an indexing interface,\n * ie v[0], v[1]. It does this by subclassing Array.\n * setter/getters are used to provide .x and .y.\n * This is *much* slower than a class with .x and .y properties, unfortunately.\n * However some algorithms are much easier to code with indices!!\n */\nclass IndexedVector2d extends Array {\n    // implement methods for Array here\n    constructor(x, y) {\n        super(2);\n        this[0] = x;\n        this[1] = y;\n    }\n    clone() {\n        return new IndexedVector2d(this[0], this[1]);\n    }\n    get x() {\n        return this[0];\n    }\n    set x(f) {\n        this[0] = f;\n    }\n    get y() {\n        return this[1];\n    }\n    set y(f) {\n        this[1] = f;\n    }\n    Length() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1]);\n    }\n    LengthSquared() {\n        return this[0] * this[0] + this[1] * this[1];\n    }\n    at(i) {\n        return this[i];\n    }\n    set(b) {\n        this[0] = b.x;\n        this[1] = b.y;\n        return this;\n    }\n    addv(b) {\n        this[0] += b.x;\n        this[1] += b.y;\n        return this;\n    }\n    subv(b) {\n        this[0] -= b[0];\n        this[1] -= b[1];\n        return this;\n    }\n    mulf(f) {\n        this[0] *= f;\n        this[1] *= f;\n        return this;\n    }\n    divf(f) {\n        this[0] /= f;\n        this[1] /= f;\n        return this;\n    }\n}\nexports.IndexedVector2d = IndexedVector2d;\n/**\n * This is a Vector2d to use for constants. unfortunately\n * javascript really doesn't support this kind of thing very well!\n * We throw exceptions so that hopefully you can find the problems in your code.\n */\nclass Vector2dConstant {\n    // implement methods for Array here\n    constructor(x, y) {\n        this.xx = x;\n        this.yy = y;\n    }\n    toString() {\n        return \"[\" + this.xx + \",\" + this.yy + \"]\";\n    }\n    clone() {\n        return new g3Vector2d(this.xx, this.yy);\n    }\n    get x() {\n        return this.xx;\n    }\n    set x(f) {\n        throw \"called x= on constant!\";\n    }\n    get y() {\n        return this.yy;\n    }\n    set y(f) {\n        throw \"called y= on constant!\";\n    }\n}\nexports.Vector2dConstant = Vector2dConstant;\n//# sourceMappingURL=Vector2d.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/types/Vector2d.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Constants_1 = require(\"./Constants\");\nclass MathUtil {\n    static IsFinite(d) {\n        return Number.isFinite(d);\n    }\n    static EpsilonEqual(a, b, epsilon = Constants_1.default.Epsilon) {\n        return Math.abs(a - b) < epsilon;\n    }\n    static PrecisionEqual(a, b, digits) {\n        let shift = Math.pow(10, digits);\n        return Math.round(a * shift) == Math.round(b * shift);\n    }\n    static Clamp(f, low, high) {\n        return (f < low) ? low : (f > high) ? high : f;\n    }\n    static RangeClamp(fValue, fMinMaxValue) {\n        return this.Clamp(fValue, -Math.abs(fMinMaxValue), Math.abs(fMinMaxValue));\n    }\n    static SignedClamp(f, fMax) {\n        return this.Clamp(Math.abs(f), 0, fMax) * Math.sign(f);\n    }\n    static SignedClamp2(f, fMin, fMax) {\n        return this.Clamp(Math.abs(f), fMin, fMax) * Math.sign(f);\n    }\n    // clamps theta to angle interval [min,max]. should work for any theta,\n    // regardless of cycles, however min & max values should be in range\n    // [-360,360] and min < max\n    static ClampAngleDeg(theta, min, max) {\n        // convert interval to center/extent - [c-e,c+e]\n        let c = (min + max) * 0.5;\n        let e = max - c;\n        // get rid of extra rotations\n        theta = theta % 360;\n        // shift to origin, then convert theta to +- 180\n        theta -= c;\n        if (theta < -180)\n            theta += 360;\n        else if (theta > 180)\n            theta -= 360;\n        // clamp to extent\n        if (theta < -e)\n            theta = -e;\n        else if (theta > e)\n            theta = e;\n        // shift back\n        return theta + c;\n    }\n    // for ((i++) % N)-type loops, but where we might be using (i--)\n    static WrapSignedIndex(val, mod) {\n        while (val < 0)\n            val += mod;\n        return val % mod;\n    }\n    // there are fast approximations to this...\n    static InvSqrt(f) {\n        return f / Math.sqrt(f);\n    }\n    // normal Atan2 returns in range [-pi,pi], this shifts to [0,2pi]\n    static Atan2Positive(y, x) {\n        let theta = Math.atan2(y, x);\n        if (theta < 0)\n            theta = (2 * Math.PI) + theta;\n        return theta;\n    }\n    static Lerp(a, b, t) {\n        return (1 - t) * a + (t) * b;\n    }\n    // code adapted from http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm\n    //    Return: >0 for P2 left of the line through P0 and P1\n    //            =0 for P2 on the line\n    //            <0 for P2 right of the line\n    static IsLeft(P0, P1, P2) {\n        return Math.sign(((P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y)));\n    }\n}\nexports.default = MathUtil;\n//# sourceMappingURL=MathUtil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/MathUtil.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass g3GeneralPolygon2d {\n    constructor() {\n        this.outer = null;\n        this.OuterIsClockwise = false;\n        this.Holes = [];\n    }\n    get Outer() {\n        return this.outer;\n    }\n    set Outer(p) {\n        this.outer = p;\n        this.OuterIsClockwise = p.IsClockwise;\n    }\n    AddHole(hole, bCheck = true) {\n        if (this.outer == null)\n            throw \"GeneralPolygon2d.AddHole: outer polygon not set!\";\n        // need to implement these functions\n        // if ( bCheck ) {\n        //     if ( this.outer.Contains(hole) == false )\n        //         throw \"GeneralPolygon2d.AddHole: outer does not contain hole!\";\n        //     // [RMS] segment/segment intersection broken?\n        //     for ( let hole1 in this.holes ) {\n        //         if ( hole.Intersects(hole2) )\n        //             throw \"GeneralPolygon2D.AddHole: new hole intersects existing hole!\";\n        //     }\n        // }\n        let holecw = hole.IsClockwise;\n        if (this.OuterIsClockwise == holecw)\n            throw \"GeneralPolygon2D.AddHole: new hole has same orientation as outer polygon!\";\n        this.Holes.push(hole);\n    }\n    get HasHoles() {\n        return this.Holes.length > 0;\n    }\n    get Area() {\n        let sign = (this.OuterIsClockwise) ? -1.0 : 1.0;\n        let dArea = sign * this.outer.SignedArea;\n        for (let i = 0; i < this.Holes.length; ++i) {\n            dArea += sign * this.Holes[i].SignedArea;\n        }\n        return dArea;\n    }\n    get Perimeter() {\n        let perim = this.outer.Perimeter;\n        for (let i = 0; i < this.Holes.length; ++i) {\n            perim += this.Holes[i].Perimeter;\n        }\n        return perim;\n    }\n    get Bounds() {\n        let box = this.outer.Bounds;\n        for (let i = 0; i < this.Holes.length; ++i) {\n            box.ContainBox(this.Holes[i].Bounds);\n        }\n        return box;\n    }\n}\nexports.g3GeneralPolygon2d = g3GeneralPolygon2d;\n//# sourceMappingURL=GeneralPolygon2d.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/curve2/GeneralPolygon2d.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MathUtil_1 = require(\"../util/MathUtil\");\nconst g3 = require(\"../g3\");\nconst Constants_1 = require(\"../util/Constants\");\nclass g3Polygon2d {\n    constructor(count = 0) {\n        this.vertices = new Array(count);\n        this.Timestamp = 0;\n    }\n    clone() {\n        let p = new g3Polygon2d();\n        p.vertices = this.vertices.slice();\n        p.Timestamp = this.Timestamp;\n        return p;\n    }\n    get VertexCount() {\n        return this.vertices.length;\n    }\n    GetVertex(index) {\n        return this.vertices[index].clone();\n    }\n    SetVertex(index, value) {\n        let p = this.vertices[index];\n        p.x = value.x;\n        p.y = value.y;\n        this.Timestamp++;\n    }\n    get Start() {\n        return this.vertices[0].clone();\n    }\n    get End() {\n        return this.vertices[this.vertices.length - 1].clone();\n    }\n    get Bounds() {\n        if (this.vertices.length == 0) {\n            return Constants_1.default.AxisAlignedBox2d_Empty;\n        }\n        let box = g3.AxisAlignedBox2d(this.vertices[0], this.vertices[0]);\n        for (let i = 1; i < this.vertices.length; ++i) {\n            box.ContainPoint(this.vertices[i]);\n        }\n        return box;\n    }\n    AppendVertex(v) {\n        this.vertices.push(g3.Vector2d(v.x, v.y));\n        this.Timestamp++;\n    }\n    AppendArray(v) {\n        if (v.length % 2 != 0) {\n            throw \"Polygon2d.Append: array size is not even\";\n        }\n        let N = v.length / 2;\n        for (let i = 0; i < N; ++i) {\n            this.vertices.push(g3.Vector2d(v[2 * i], v[2 * i + 1]));\n        }\n        this.Timestamp++;\n    }\n    Reverse() {\n        this.vertices.reverse();\n        this.Timestamp++;\n    }\n    // GetTangent()\n    // GetBounds()\n    get SignedArea() {\n        let fArea = 0;\n        let N = this.vertices.length;\n        for (let i = 0; i < N; ++i) {\n            let j = (i + 1) % N;\n            let v1 = this.vertices[i];\n            let v2 = this.vertices[j];\n            fArea += v1.x * v2.y - v1.y * v2.x;\n        }\n        return fArea / 2;\n    }\n    get IsClockwise() {\n        return this.SignedArea < 0;\n    }\n    get Perimeter() {\n        let fPerim = 0;\n        let N = this.vertices.length;\n        for (let i = 0; i < N; ++i) {\n            let j = (i + 1) % N;\n            let dx = this.vertices[j].x - this.vertices[i].x;\n            let dy = this.vertices[j].y - this.vertices[i].y;\n            fPerim += Math.sqrt(dx * dx + dy * dy);\n        }\n        return fPerim;\n    }\n    ContainsPoint(vTest) {\n        let nWindingNumber = 0; // winding number counter\n        let N = this.vertices.length;\n        for (let i = 0; i < N; ++i) {\n            let iNext = (i + 1) % N;\n            if (this.vertices[i].y <= vTest.y) {\n                // start y <= P.y\n                if (this.vertices[iNext].y > vTest.y) {\n                    if (MathUtil_1.default.IsLeft(this.vertices[i], this.vertices[iNext], vTest) > 0)\n                        ++nWindingNumber; // have a valid up intersect\n                }\n            }\n            else {\n                // start y > P.y (no test needed)\n                if (this.vertices[iNext].y <= vTest.y) {\n                    if (MathUtil_1.default.IsLeft(this.vertices[i], this.vertices[iNext], vTest) < 0)\n                        --nWindingNumber; // have a valid down intersect\n                }\n            }\n        }\n        return nWindingNumber != 0;\n    }\n}\nexports.g3Polygon2d = g3Polygon2d;\n//# sourceMappingURL=Polygon2d.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/curve2/Polygon2d.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}